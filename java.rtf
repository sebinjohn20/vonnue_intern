{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil\fcharset1 Cambria Math;}{\f2\fnil\fcharset0 Cambria Math;}{\f3\fnil\fcharset1 Segoe UI Symbol;}{\f4\fnil\fcharset1 Segoe UI Symbol;}{\f5\fnil Segoe UI Symbol;}}
{\*\generator Riched20 10.0.19041}{\*\mmathPr\mmathFont1\mwrapIndent1440 }\viewkind4\uc1 
\pard\sa200\sl276\slmult1\b\f0\fs22\lang9\par
Scope is the area of a program where a variable can be used or accessed.\par
\b0\par
Global scope \f1\u8594?\f0  variable can be used anywhere.\par
\par
Local scope \f1\u8594?\f0  variable can be used only inside a function or block.\par
\b Lexical\f2  \f0 environment\f2  \f0 decides\f2  \f0 which\f2  \f0 variables\f2  \f0 are\f2  \f0 accessible\f2  \f0 to\f2  \f0 a\f2  \f0 function\f2  \f0 based\f2  \f0 on\f2  \f0 where\f2  \f0 it\f2  \f0 was\f2  \f0 written\f2  \f0 in\f2  \f0 the\f2  \f0 code\f2 .\f0\par
\par
\par
The\f2  \f0 Temporal\f2  \f0 Dead\f2  \f0 Zone\f2  (\f0 TDZ\f2 ) \f0 in\f2  \f0 JavaScript\f2  \f0 is\f2  \f0 the\f2  \f0 time\f2  \f0 period\f2  \f0 between\f2  \f0 entering\f2  \f0 a\f2  \f0 scope\f2  \f0 and\f2  \f0 the\f2  \f0 moment\f2  \f0 a\f2  \f0 let\f2  \f0 or\f2  \f0 const\f2  \f0 variable\f2  \f0 is\f2  \f0 declared\f2 , \f0 during\f2  \f0 which\f2  \f0 the\f2  \f0 variable\f2  \f0 exists\f2  \f0 in\f2  \f0 memory\f2  \f0 but\f2  \f0 cannot\f2  \f0 be\f2  \f0 accessed\f2 .\par
\par
\b0\f0\lang9\par
\b A closure is a function that remembers and can access variables from its outer (parent) scope even after that outer function has finished executing.\par
\par
innerText vs innerHTML in JavaScript.\par
\b0\par
innerText \f1\u8594?\f0  returns/sets only the visible text (ignores HTML tags).\par
innerHTML \f1\u8594?\f0  returns/sets the HTML code + text inside the element.\par
\b DOM\f2  (\f0 Document\f2  \f0 Object\f2  \f0 Model\f2 )\f0\par
\b0\par

\pard\sa200\sl240\slmult1 The\f2  \f0 DOM\f2  \f0 is\f2  \f0 a\f2  \f0 programming\f2  \f0 interface\f2  \f0 that\f2  \f0 represents\f2  \f0 an\f2  \f0 HTML\f2  \f0 or\f2  \f0 XML\f2  \f0 document\f2  \f0 as\f2  \f0 a\f2  \f0 tree\f2  \f0 structure\f2 .\f0\par
\par
Each\f2  \f0 HTML\f2  \f0 element\f2  (\f0 like\f2  <\f0 h1\f2 >, <\f0 p\f2 >, <\f0 div\f2 >) \f0 becomes\f2  \f0 a\f2  \f0 node\f2  \f0 in\f2  \f0 this\f2  \f0 tree\f2 .\f0\par
\par
With\f2  \f0 the\f2  \f0 DOM\f2 , \f0 JavaScript\f2  \f0 can\f2  \f0 access\f2 , \f0 change\f2 , \f0 add\f2 , \f0 or\f2  \f0 delete\f2  \f0 elements\f2  \f0 in\f2  \f0 a\f2  \f0 webpage\line\b What\f2  \f0 is\f2  \f0 querySelector\f2 ?\b0\f0\par
document\f2 .\f0 querySelector\f2 () \f0 lets\f2  \f0 you\f2  \f0 select\f2  \f0 the\f2  \f0 first\f2  \f0 element\f2  \f0 in\f2  \f0 your\f2  \f0 HTML\f2  \f0 that\f2  \f0 matches\f2  \f0 a\f2  \f0 CSS\f2  \f0 selector\f2 .\par
\line\b push() \f1\u8594? add to end\par
\par
pop() \u8594? remove from end\par
\par
unshift() \u8594? add to start\par
\par
1. var\par
\b0\par
Scope: Function-scoped (not block-scoped).\par
Hoisting: Gets hoisted (moved to the top of its scope) and initialized with undefined.\par
Re-declaration: Allowed.\par
Use case: Older JS code, rarely recommended now.\par
function testVar() \{\par
  if (true) \{\par
    var x = 10;  // function-scoped\par
  \}\par
  console.log(x); // \f3\u9989?\f2  Works (10), even outside the if-block\par
\}\par
testVar();\line\b 2. let\b0\par
Scope: Block-scoped (only available inside \{\}).\par
Hoisting: Gets hoisted but not initialized, so using it before declaration gives ReferenceError (called "Temporal Dead Zone").\par
Re-declaration: \f3\u10060?\f2  Not allowed in the same scope.\par
function testLet() \{\par
  if (true) \{\par
    let y = 20; // block-scoped\par
    console.log(y); // \f3\u9989?\f2  Works here\par
  \}\par
  // console.log(y); // \f3\u10060?\f2  ReferenceError (outside block)\par
\}\par
testLet();\line\b 3. const\b0\par
\par
Scope: Block-scoped (like let).\par
\par
Hoisting: Same as let (temporal dead zone).\par
\par
Re-declaration: \f3\u10060?\f2  Not allowed.\par
\par
Re-assignment: \f3\u10060?\f2  Not allowed (must assign a value at declaration).\par
\par
Use case: When the value should not change.\line const PI = 3.14159;\par
console.log(PI); // \f3\u9989?\f2  3.14159\par
\par
// PI = 3.14; // \f3\u10060?\f2  TypeError: Assignment to constant variable\line\b Important: const prevents re-assignment, but if the variable is an object or array, its contents can still change\b0 .\par
eature\tab var\tab let\tab const\par
Scope\tab Function-scoped\tab Block-scoped\tab Block-scoped\par
Hoisting\tab Yes (initialized as undefined)\tab Yes (but temporal dead zone)\tab Yes (but temporal dead zone)\par
Re-declaration\tab\f3\u9989?\f2  Allowed\tab\f3\u10060?\f2  Not allowed\tab\f3\u10060?\f2  Not allowed\par
Re-assignment\tab\f3\u9989?\f2  Allowed\tab\f3\u9989?\f2  Allowed\tab\f3\u10060?\f2  Not allowed\par
Best to use\tab Legacy code only\tab When value changes\tab For constants / fixed values\par
\par
\b Definition of localStorage\b0\par
\par
localStorage is part of the Web Storage API in modern web browsers.\par
It allows you to store key\endash value pairs in a web browser without expiration.\par
The data remains saved even after the page is reloaded or the browser is closed and reopened.\par
Storage capacity is usually ~5MB per domain.\par
Values are always stored as strings.\par
You can use it to store user preferences, session data, small app states, etc.\par
\par
\b Why JSON.stringify() is used?\b0\par
localStorage can only store strings (text).\par
If you try to store an object or array directly, it will be converted to "[object Object]", which is useless.\par
So, we convert objects/arrays into a string representation using JSON.stringify() before saving.\par
\b\f0\lang9 Definition\b0\par
\par
JSON.parse() is a JavaScript function that takes a JSON-formatted string and converts it into a JavaScript object or array.\par
Input \f1\u8594? JSON string (text)\par
Output \u8594? Object, Array, Number, Boolean, or Null\par
\par
\par
\b The constructor in JavaScript is a special method of a class.\par
It\rquote s called automatically whenever you create a new object from that class (using new).\par
\par
\fs36\par
\f4\u-10179?\u-9014?\f2  \f5 Shallow\f2  \f5 Copy\f2  \f5 vs\f2  \f5 Deep\f2  \f5 Copy\f2  \f5 in\f2  \f5 JavaScript\par
\b0\fs22 Feature\tab Shallow\f2  \f5 Copy\tab Deep\f2  \f5 Copy\par
Definition\tab Copies\f2  \f5 only\f2  \f5 the\f2  \f5 first\f2  \f5 level\f2  \f5 of\f2  \f5 properties\f2 ; \f5 nested\f2  \f5 objects\f2 /\f5 arrays\f2  \f5 are\f2  \f5 still\f2  \f5 referenced\f2 .\f5\tab Creates\f2  \f5 a\f2  \f5 completely\f2  \f5 independent\f2  \f5 clone\f2 , \f5 including\f2  \f5 nested\f2  \f5 objects\f2  \f5 and\f2  \f5 arrays\f2 .\f5\par
Methods\tab\f2 - \f5 Object\f2 .\f5 assign\f2 (\{\}, \f5 obj\f2 )\f5\par
\f2 - \{ ...\f5 obj\f2  \} (\f5 spread\f2  \f5 operator\f2 )\f5\tab\f2 - \f5 JSON\f2 .\f5 parse\f2 (\f5 JSON\f2 .\f5 stringify\f2 (\f5 obj\f2 ))\f5\par
\f2 - \f5 structuredClone\f2 (\f5 obj\f2 ) (\f5 modern\f2 )\f5\par
\f2 - \f5 Custom\f2  \f5 recursive\f2  \f5 function\par
Effect\f2  \f5 on\f2  \f5 Nested\f2  \f5 Objects\tab Shared\f2  \f5 references\f2  \f1\u8594? changes in nested objects affect both copies.\tab Independent copies \u8594? changes in nested objects do NOT affect the original.\par
Performance\tab Faster (less work).\tab Slower (recursively copies everything).\par
Handles Functions, Dates, Maps, Sets\tab\f3\u9989?\f2  \f5 Yes\f2  (\f5 but\f2  \f5 references\f2  \f5 remain\f2 ).\f5\tab\f3\u10060?\f2  \f5 JSON\f2  \f5 method\f2  \f5 fails\f2  \f5 for\f2  \f5 these\par
\f3\u9989?\f2  \f5 structuredClone\f2 () \f5 supports\f2  \f5 most\f2  \f5 types\par
\f3\u9989?\f2  \f5 Recursive\f2  \f5 function\f2  \f5 if\f2  \f5 implemented\f2  \f5 correctly\par
Use\f2  \f5 Case\tab When\f2  \f5 object\f2  \f5 is\f2  \f5 simple\f2  (\f5 no\f2  \f5 nested\f2  \f5 objects\f2 /\f5 arrays\f2 ) \f5 OR\f2  \f5 when\f2  \f5 shallow\f2  \f5 linking\f2  \f5 is\f2  \f5 acceptable\f2 .\f5\tab When\f2  \f5 you\f2  \f5 need\f2  \f5 a\f2  \f5 true\f2  \f5 independent\f2  \f5 copy\f2  \f5 of\f2  \f5 a\f2  \f5 com\par
\par
\par
\b Object\f2 .\f5 assign\f2 () \f5 only\f2  \f5 copies\f2  \f5 top\f2 -\f5 level\f2  \f5 properties\f2 .\par
\par
\b0\par
\par
\b 1. filter()\par
\b0\par
Purpose: Filters elements from an array based on a condition.\par
\par
Returns: A new array with elements that passed the condition.\par
\par
Does not change the shape of data (array stays array).\par
\par
Example: Get even numbers\par
let numbers = [1, 2, 3, 4, 5, 6];\par
\par
let evens = numbers.filter(num => num % 2 === 0);\par
\par
console.log(evens); // [2, 4, 6]\par
\par
\b 2. reduce()\par
\b0\par
Purpose: Reduces an array into a single value (number, string, object, map, etc.).\par
\par
Returns: Whatever you want (number, object, array, etc.) depending on how you write it.\par
\par
Very flexible (sum, average, grouping, transforming, etc.).\par
\par
Example: Find sum of numbers\par
let numbers = [1, 2, 3, 4, 5, 6];\par
\par
let sum = numbers.reduce((acc, num) => acc + num, 0);\par
\par
console.log(sum); // 21\par
\par
\par
\par
\par
\b arr.flat(Infinity) removes all nesting and makes it a single-level array.\par
\par
\par
\par
The nullish coalescing operator (??) returns the right-hand value if the left-hand value is null or undefined, otherwise it returns the left-hand value.\par
\par
\f4\u-10179?\u-9143?\f2  \f5 It\rquote s\f2  \f5 used\f2  \f5 to\f2  \f5 provide\f2  \f5 default\f2  \f5 values\f2  \f5 safely\f2  \f5 without\f2  \f5 mistakenly\f2  \f5 treating\f2  \f5 0\f2 , \f5 ""\f2 , \f5 or\f2  \f5 false\f2  \f5 as\f2  \f5 missing\f2 .\f5\par
\par
\f3\u9989?\f2  \f5 Syntax\par
let\f2  \f5 result\f2  = \f5 value1\f2  ?? \f5 value2\f2 ;\f5\par
\par
\par
If\f2  \f5 value1\f2  \f5 is\f2  \f5 not\f2  \f5 nullish\f2  (\f5 null\f2  \f5 or\f2  \f5 undefined\f2 ), \f1\u8594? result = value1\par
\par
If value1 is nullish, \u8594? result = value2\par
\par
\par
An anonymous function is a function that is declared without a name.\par
\b0 // Assigning an anonymous function to a variable\par
var greet = function() \{\par
    console.log("Hello, world!");\par
\};\par
\par
greet();  \par
// Output: Hello, world!\par
\par
\par
\b\par
A first-class function means that in a programming language (like JavaScript), functions are treated like any other value. They can be:\par
\b0\par
Assigned to variables\par
\par
Passed as arguments to other functions\par
\par
Returned from other functions\par
\par
Stored in data structures (like arrays or objects)\par
\par
\par
\par
\b Key Differences\par
Feature\tab Function Declaration\tab Function Expression\par
\b0 Hoisting\tab Yes\tab No\par
Name required\tab Yes\tab Can be anonymous\par
Usage before declaration\tab Works\tab Error\par
Example Syntax\tab function foo() \{\}\tab var foo = function() \{\}\par
\par
\par
\par
\b Term\tab Definition\tab Example\b0\par
Parameter\tab Variable in function definition\tab function sum(a, b) \{ ... \}\par
Argument\tab Actual value passed when calling the function\tab sum(5, 10) \u8594? 5 and 10 are arguments\par
\b\par
What is a Callback Function?\par
\b0\par
A callback function is a function that is passed as an argument to another function and is executed later inside that function.\par
\par
\b Why Use Callbacks?\par
\b0\par
To handle asynchronous operations (like waiting for a response).\par
\par
To make code more flexible and reusable.\f0\lang9\par
}
 